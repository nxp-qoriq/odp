<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Reference Manual: ODP SCHEDULER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="odpdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ODP-Logo-HQ.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API Reference Manual
   &#160;<span id="projectnumber">1.35.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__odp__scheduler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ODP SCHEDULER</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">API Description</h2>
<p>Event scheduler for work load balancing and prioritization. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group information.  <a href="structodp__schedule__group__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__param__t.html">odp_schedule_param_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler parameters.  <a href="structodp__schedule__param__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler capabilities.  <a href="structodp__schedule__capability__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule configuration.  <a href="structodp__schedule__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga082e6855e67281d9f868152c7daa844a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga082e6855e67281d9f868152c7daa844a">ODP_SCHED_WAIT</a>&#160;&#160;&#160;UINT64_MAX</td></tr>
<tr class="separator:ga082e6855e67281d9f868152c7daa844a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9116776b8262a74af7dac7ef46fc7ace"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga9116776b8262a74af7dac7ef46fc7ace">ODP_SCHED_NO_WAIT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga9116776b8262a74af7dac7ef46fc7ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90bf46fce3105dfa3bb2e5f258a7236a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga90bf46fce3105dfa3bb2e5f258a7236a">ODP_SCHED_GROUP_NAME_LEN</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ga90bf46fce3105dfa3bb2e5f258a7236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3f3389f35a947facd5f627303778b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaca3f3389f35a947facd5f627303778b6">ODP_SCHED_PRIO_HIGHEST</a></td></tr>
<tr class="separator:gaca3f3389f35a947facd5f627303778b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046f2bec4fef89eee60aa05703dddaeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga046f2bec4fef89eee60aa05703dddaeb">ODP_SCHED_PRIO_NORMAL</a></td></tr>
<tr class="separator:ga046f2bec4fef89eee60aa05703dddaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd8237b327ae2bbc28d26997162c9dc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gabd8237b327ae2bbc28d26997162c9dc1">ODP_SCHED_PRIO_LOWEST</a></td></tr>
<tr class="separator:gabd8237b327ae2bbc28d26997162c9dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd0560d25e62ad6ee1dd01e37d7a087"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7bd0560d25e62ad6ee1dd01e37d7a087">ODP_SCHED_PRIO_DEFAULT</a></td></tr>
<tr class="separator:ga7bd0560d25e62ad6ee1dd01e37d7a087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ba135fc660e1c050aa25ec6744ec584"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga2ba135fc660e1c050aa25ec6744ec584">ODP_SCHED_SYNC_PARALLEL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga2ba135fc660e1c050aa25ec6744ec584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7efc5cfc27ef416312f5adb8bdc392"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4b7efc5cfc27ef416312f5adb8bdc392">ODP_SCHED_SYNC_ATOMIC</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga4b7efc5cfc27ef416312f5adb8bdc392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df3696ebf4528ecc6e69ae3fff040fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4df3696ebf4528ecc6e69ae3fff040fd">ODP_SCHED_SYNC_ORDERED</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga4df3696ebf4528ecc6e69ae3fff040fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga8a6ab4ff9386d9a4ffcb4b19d516a3fb">ODP_SCHED_GROUP_INVALID</a>&#160;&#160;&#160;((<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>)-1)</td></tr>
<tr class="separator:ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf463b15ad978dac0bf77c0110232b504"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaf463b15ad978dac0bf77c0110232b504">ODP_SCHED_GROUP_ALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gaf463b15ad978dac0bf77c0110232b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72125b596aa5d2e61dd61e177516e24e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga72125b596aa5d2e61dd61e177516e24e">ODP_SCHED_GROUP_WORKER</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga72125b596aa5d2e61dd61e177516e24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d0a3ad4e57fabf61aa84b59e688a13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae8d0a3ad4e57fabf61aa84b59e688a13">ODP_SCHED_GROUP_CONTROL</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:gae8d0a3ad4e57fabf61aa84b59e688a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga05c15f8076326b98fe2fc534dcc6b319"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga05c15f8076326b98fe2fc534dcc6b319">odp_schedule_sync_t</a></td></tr>
<tr class="separator:ga05c15f8076326b98fe2fc534dcc6b319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd27b316530d297eab83d851bf2deb8"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a></td></tr>
<tr class="separator:ga3cd27b316530d297eab83d851bf2deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19b1849213f57b9c85dec6168e6b466"><td class="memItemLeft" align="right" valign="top"><a id="gae19b1849213f57b9c85dec6168e6b466"></a>
typedef struct <a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae19b1849213f57b9c85dec6168e6b466">odp_schedule_group_info_t</a></td></tr>
<tr class="memdesc:gae19b1849213f57b9c85dec6168e6b466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group information. <br /></td></tr>
<tr class="separator:gae19b1849213f57b9c85dec6168e6b466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e9d26217f2f689b2611298dec5daf7"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga33e9d26217f2f689b2611298dec5daf7">odp_schedule_prio_t</a></td></tr>
<tr class="memdesc:ga33e9d26217f2f689b2611298dec5daf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling priority level.  <a href="group__odp__scheduler.html#ga33e9d26217f2f689b2611298dec5daf7">More...</a><br /></td></tr>
<tr class="separator:ga33e9d26217f2f689b2611298dec5daf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f168fef5bfd38bc561966c7fe069938"><td class="memItemLeft" align="right" valign="top"><a id="ga7f168fef5bfd38bc561966c7fe069938"></a>
typedef struct <a class="el" href="structodp__schedule__param__t.html">odp_schedule_param_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7f168fef5bfd38bc561966c7fe069938">odp_schedule_param_t</a></td></tr>
<tr class="memdesc:ga7f168fef5bfd38bc561966c7fe069938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler parameters. <br /></td></tr>
<tr class="separator:ga7f168fef5bfd38bc561966c7fe069938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a101e18c1dfcf21e2ff23f376858a4"><td class="memItemLeft" align="right" valign="top"><a id="ga86a101e18c1dfcf21e2ff23f376858a4"></a>
typedef struct <a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga86a101e18c1dfcf21e2ff23f376858a4">odp_schedule_capability_t</a></td></tr>
<tr class="memdesc:ga86a101e18c1dfcf21e2ff23f376858a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler capabilities. <br /></td></tr>
<tr class="separator:ga86a101e18c1dfcf21e2ff23f376858a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535b77a27ebe6031c1f579b97f989c8d"><td class="memItemLeft" align="right" valign="top"><a id="ga535b77a27ebe6031c1f579b97f989c8d"></a>
typedef struct <a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga535b77a27ebe6031c1f579b97f989c8d">odp_schedule_config_t</a></td></tr>
<tr class="memdesc:ga535b77a27ebe6031c1f579b97f989c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule configuration. <br /></td></tr>
<tr class="separator:ga535b77a27ebe6031c1f579b97f989c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0a0d2673cc7371d5c5d782d13a485b8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8">odp_schedule_wait_time</a> (uint64_t ns)</td></tr>
<tr class="memdesc:gab0a0d2673cc7371d5c5d782d13a485b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule wait time.  <a href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8">More...</a><br /></td></tr>
<tr class="separator:gab0a0d2673cc7371d5c5d782d13a485b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ca1012ebb16ff8b9752b958dc45ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6">odp_schedule</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, uint64_t wait)</td></tr>
<tr class="memdesc:gae4ca1012ebb16ff8b9752b958dc45ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an event.  <a href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6">More...</a><br /></td></tr>
<tr class="separator:gae4ca1012ebb16ff8b9752b958dc45ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f1bae924466cc2b57563f8fe2dc0d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1">odp_schedule_multi</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, uint64_t wait, <a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> events[], int num)</td></tr>
<tr class="memdesc:ga34f1bae924466cc2b57563f8fe2dc0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule multiple events.  <a href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1">More...</a><br /></td></tr>
<tr class="separator:ga34f1bae924466cc2b57563f8fe2dc0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa388723ac8b02b37675476fabd8fb014"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa388723ac8b02b37675476fabd8fb014">odp_schedule_multi_wait</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, <a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> events[], int num)</td></tr>
<tr class="memdesc:gaa388723ac8b02b37675476fabd8fb014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule, wait for events.  <a href="group__odp__scheduler.html#gaa388723ac8b02b37675476fabd8fb014">More...</a><br /></td></tr>
<tr class="separator:gaa388723ac8b02b37675476fabd8fb014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ae1ac2ac704684d0a7087a311c73f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga17ae1ac2ac704684d0a7087a311c73f4">odp_schedule_multi_no_wait</a> (<a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *from, <a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> events[], int num)</td></tr>
<tr class="memdesc:ga17ae1ac2ac704684d0a7087a311c73f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule, do not wait for events.  <a href="group__odp__scheduler.html#ga17ae1ac2ac704684d0a7087a311c73f4">More...</a><br /></td></tr>
<tr class="separator:ga17ae1ac2ac704684d0a7087a311c73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9868ccb25b6631ef29cc921ee2e522b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga9868ccb25b6631ef29cc921ee2e522b0">odp_schedule_pause</a> (void)</td></tr>
<tr class="memdesc:ga9868ccb25b6631ef29cc921ee2e522b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause scheduling.  <a href="group__odp__scheduler.html#ga9868ccb25b6631ef29cc921ee2e522b0">More...</a><br /></td></tr>
<tr class="separator:ga9868ccb25b6631ef29cc921ee2e522b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16f217bd1654f854a720130dbd01a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaf16f217bd1654f854a720130dbd01a49">odp_schedule_resume</a> (void)</td></tr>
<tr class="memdesc:gaf16f217bd1654f854a720130dbd01a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume scheduling.  <a href="group__odp__scheduler.html#gaf16f217bd1654f854a720130dbd01a49">More...</a><br /></td></tr>
<tr class="separator:gaf16f217bd1654f854a720130dbd01a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bfbbe5a45d721f9af622296fa97b8e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4">odp_schedule_release_atomic</a> (void)</td></tr>
<tr class="memdesc:ga7bfbbe5a45d721f9af622296fa97b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the current atomic context.  <a href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4">More...</a><br /></td></tr>
<tr class="separator:ga7bfbbe5a45d721f9af622296fa97b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9e0e2bfa0f014069ae7b66bdba0065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065">odp_schedule_release_ordered</a> (void)</td></tr>
<tr class="memdesc:gaab9e0e2bfa0f014069ae7b66bdba0065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the current ordered context.  <a href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065">More...</a><br /></td></tr>
<tr class="separator:gaab9e0e2bfa0f014069ae7b66bdba0065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17b9ca6d2b8bd76e31023779455474c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa17b9ca6d2b8bd76e31023779455474c">odp_schedule_prefetch</a> (int num)</td></tr>
<tr class="memdesc:gaa17b9ca6d2b8bd76e31023779455474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefetch events for next schedule call.  <a href="group__odp__scheduler.html#gaa17b9ca6d2b8bd76e31023779455474c">More...</a><br /></td></tr>
<tr class="separator:gaa17b9ca6d2b8bd76e31023779455474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d91b9144cf2ccdcb112b7376a38aeaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf">odp_schedule_max_prio</a> (void)</td></tr>
<tr class="memdesc:ga9d91b9144cf2ccdcb112b7376a38aeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum scheduling priority level.  <a href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf">More...</a><br /></td></tr>
<tr class="separator:ga9d91b9144cf2ccdcb112b7376a38aeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b421f0656421e67cc7fd841e5576b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5">odp_schedule_min_prio</a> (void)</td></tr>
<tr class="memdesc:ga53b421f0656421e67cc7fd841e5576b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum scheduling priority level.  <a href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5">More...</a><br /></td></tr>
<tr class="separator:ga53b421f0656421e67cc7fd841e5576b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94034a7f591f3f549099aebb098f7e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga94034a7f591f3f549099aebb098f7e05">odp_schedule_default_prio</a> (void)</td></tr>
<tr class="memdesc:ga94034a7f591f3f549099aebb098f7e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default scheduling priority level.  <a href="group__odp__scheduler.html#ga94034a7f591f3f549099aebb098f7e05">More...</a><br /></td></tr>
<tr class="separator:ga94034a7f591f3f549099aebb098f7e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae380898e8c1cac6a96cd539a7603a31d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae380898e8c1cac6a96cd539a7603a31d">odp_schedule_num_prio</a> (void)</td></tr>
<tr class="memdesc:gae380898e8c1cac6a96cd539a7603a31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of scheduling priorities.  <a href="group__odp__scheduler.html#gae380898e8c1cac6a96cd539a7603a31d">More...</a><br /></td></tr>
<tr class="separator:gae380898e8c1cac6a96cd539a7603a31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d">odp_schedule_config_init</a> (<a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *config)</td></tr>
<tr class="memdesc:ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize schedule configuration options.  <a href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d">More...</a><br /></td></tr>
<tr class="separator:ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b51ebd46adeb6aa7805fccb00144df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df">odp_schedule_config</a> (const <a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *config)</td></tr>
<tr class="memdesc:gaa1b51ebd46adeb6aa7805fccb00144df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global schedule configuration.  <a href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df">More...</a><br /></td></tr>
<tr class="separator:gaa1b51ebd46adeb6aa7805fccb00144df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde3ebecd35c0442a2e2a20144af0d80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80">odp_schedule_capability</a> (<a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a> *capa)</td></tr>
<tr class="memdesc:gabde3ebecd35c0442a2e2a20144af0d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query scheduler capabilities.  <a href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80">More...</a><br /></td></tr>
<tr class="separator:gabde3ebecd35c0442a2e2a20144af0d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade17d812771d4e386aac0810b05fa0e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gade17d812771d4e386aac0810b05fa0e5">odp_schedule_group_create</a> (const char *name, const <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *mask)</td></tr>
<tr class="memdesc:gade17d812771d4e386aac0810b05fa0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group create.  <a href="group__odp__scheduler.html#gade17d812771d4e386aac0810b05fa0e5">More...</a><br /></td></tr>
<tr class="separator:gade17d812771d4e386aac0810b05fa0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga789089301ab1da404d927deace0c2492"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga789089301ab1da404d927deace0c2492">odp_schedule_group_destroy</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group)</td></tr>
<tr class="memdesc:ga789089301ab1da404d927deace0c2492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule group destroy.  <a href="group__odp__scheduler.html#ga789089301ab1da404d927deace0c2492">More...</a><br /></td></tr>
<tr class="separator:ga789089301ab1da404d927deace0c2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5021b647374ccf445765138c520aea2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga5021b647374ccf445765138c520aea2c">odp_schedule_group_lookup</a> (const char *name)</td></tr>
<tr class="memdesc:ga5021b647374ccf445765138c520aea2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a schedule group by name.  <a href="group__odp__scheduler.html#ga5021b647374ccf445765138c520aea2c">More...</a><br /></td></tr>
<tr class="separator:ga5021b647374ccf445765138c520aea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7a7ab39ee69f8538edd9dd506127b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga3f7a7ab39ee69f8538edd9dd506127b6">odp_schedule_group_join</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, const <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *mask)</td></tr>
<tr class="memdesc:ga3f7a7ab39ee69f8538edd9dd506127b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a schedule group.  <a href="group__odp__scheduler.html#ga3f7a7ab39ee69f8538edd9dd506127b6">More...</a><br /></td></tr>
<tr class="separator:ga3f7a7ab39ee69f8538edd9dd506127b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8b1785115b6d2be6aae0f5614dc604"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga7f8b1785115b6d2be6aae0f5614dc604">odp_schedule_group_leave</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, const <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *mask)</td></tr>
<tr class="memdesc:ga7f8b1785115b6d2be6aae0f5614dc604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a schedule group.  <a href="group__odp__scheduler.html#ga7f8b1785115b6d2be6aae0f5614dc604">More...</a><br /></td></tr>
<tr class="separator:ga7f8b1785115b6d2be6aae0f5614dc604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f82ee3eb52b2a0af6c1629334942b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga0f82ee3eb52b2a0af6c1629334942b5c">odp_schedule_group_thrmask</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *thrmask)</td></tr>
<tr class="memdesc:ga0f82ee3eb52b2a0af6c1629334942b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a schedule group's thrmask.  <a href="group__odp__scheduler.html#ga0f82ee3eb52b2a0af6c1629334942b5c">More...</a><br /></td></tr>
<tr class="separator:ga0f82ee3eb52b2a0af6c1629334942b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76f3ebf512c382a95cb64ac2b843c7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f">odp_schedule_group_info</a> (<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> group, <a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a> *info)</td></tr>
<tr class="memdesc:gad76f3ebf512c382a95cb64ac2b843c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a schedule group.  <a href="group__odp__scheduler.html#gad76f3ebf512c382a95cb64ac2b843c7f">More...</a><br /></td></tr>
<tr class="separator:gad76f3ebf512c382a95cb64ac2b843c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb827ae9d816cc6e3bade16f2e4ce00d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d">odp_schedule_order_lock</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:gafb827ae9d816cc6e3bade16f2e4ce00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire ordered context lock.  <a href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d">More...</a><br /></td></tr>
<tr class="separator:gafb827ae9d816cc6e3bade16f2e4ce00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f07fe4b73a14a6ef06414a2c10ddc2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga8f07fe4b73a14a6ef06414a2c10ddc2a">odp_schedule_order_unlock</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:ga8f07fe4b73a14a6ef06414a2c10ddc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ordered context lock.  <a href="group__odp__scheduler.html#ga8f07fe4b73a14a6ef06414a2c10ddc2a">More...</a><br /></td></tr>
<tr class="separator:ga8f07fe4b73a14a6ef06414a2c10ddc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gaf4a9ff2ad12781e8ee8cfd722ec7cd5c">odp_schedule_order_unlock_lock</a> (uint32_t unlock_index, uint32_t lock_index)</td></tr>
<tr class="memdesc:gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release existing ordered context lock and acquire a new lock.  <a href="group__odp__scheduler.html#gaf4a9ff2ad12781e8ee8cfd722ec7cd5c">More...</a><br /></td></tr>
<tr class="separator:gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2c49c450d10a8d1493f49bb8bda497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga4a2c49c450d10a8d1493f49bb8bda497">odp_schedule_order_lock_start</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:ga4a2c49c450d10a8d1493f49bb8bda497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous ordered context lock Request an ordered context lock to be acquired.  <a href="group__odp__scheduler.html#ga4a2c49c450d10a8d1493f49bb8bda497">More...</a><br /></td></tr>
<tr class="separator:ga4a2c49c450d10a8d1493f49bb8bda497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39473bcdcdf480a827cbbf6249aee394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#ga39473bcdcdf480a827cbbf6249aee394">odp_schedule_order_lock_wait</a> (uint32_t lock_index)</td></tr>
<tr class="memdesc:ga39473bcdcdf480a827cbbf6249aee394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous ordered context lock wait Wait for a previously started lock acquire operation to finish.  <a href="group__odp__scheduler.html#ga39473bcdcdf480a827cbbf6249aee394">More...</a><br /></td></tr>
<tr class="separator:ga39473bcdcdf480a827cbbf6249aee394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92168433885df11eed3d22040b68e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__odp__scheduler.html#gae92168433885df11eed3d22040b68e38">odp_schedule_print</a> (void)</td></tr>
<tr class="memdesc:gae92168433885df11eed3d22040b68e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug info about scheduler.  <a href="group__odp__scheduler.html#gae92168433885df11eed3d22040b68e38">More...</a><br /></td></tr>
<tr class="separator:gae92168433885df11eed3d22040b68e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga082e6855e67281d9f868152c7daa844a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga082e6855e67281d9f868152c7daa844a">&#9670;&nbsp;</a></span>ODP_SCHED_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_WAIT&#160;&#160;&#160;UINT64_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait infinitely </p>

</div>
</div>
<a id="ga9116776b8262a74af7dac7ef46fc7ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9116776b8262a74af7dac7ef46fc7ace">&#9670;&nbsp;</a></span>ODP_SCHED_NO_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_NO_WAIT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not wait </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ipsec_api_2odp_ipsec_8c-example.html#a28">ipsec_api/odp_ipsec.c</a>, <a class="el" href="ipsec_crypto_2odp_ipsec_8c-example.html#a30">ipsec_crypto/odp_ipsec.c</a>, <a class="el" href="odp_generator_8c-example.html#a92">odp_generator.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a44">odp_l2fwd.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a13">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga90bf46fce3105dfa3bb2e5f258a7236a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90bf46fce3105dfa3bb2e5f258a7236a">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_NAME_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_NAME_LEN&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum schedule group name length in chars including null char </p>

</div>
</div>
<a id="gaca3f3389f35a947facd5f627303778b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca3f3389f35a947facd5f627303778b6">&#9670;&nbsp;</a></span>ODP_SCHED_PRIO_HIGHEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_PRIO_HIGHEST</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>This macro is equivalent of calling <a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf" title="Maximum scheduling priority level.">odp_schedule_max_prio()</a>. Use direct function call instead. </dd></dl>

</div>
</div>
<a id="ga046f2bec4fef89eee60aa05703dddaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga046f2bec4fef89eee60aa05703dddaeb">&#9670;&nbsp;</a></span>ODP_SCHED_PRIO_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_PRIO_NORMAL</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>This macro is equivalent of calling <a class="el" href="group__odp__scheduler.html#ga94034a7f591f3f549099aebb098f7e05" title="Default scheduling priority level.">odp_schedule_default_prio()</a>. Use direct function call instead. </dd></dl>

</div>
</div>
<a id="gabd8237b327ae2bbc28d26997162c9dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8237b327ae2bbc28d26997162c9dc1">&#9670;&nbsp;</a></span>ODP_SCHED_PRIO_LOWEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_PRIO_LOWEST</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>This macro is equivalent of calling <a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5" title="Minimum scheduling priority level.">odp_schedule_min_prio()</a>. Use direct function call instead. </dd></dl>

</div>
</div>
<a id="ga7bd0560d25e62ad6ee1dd01e37d7a087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd0560d25e62ad6ee1dd01e37d7a087">&#9670;&nbsp;</a></span>ODP_SCHED_PRIO_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_PRIO_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>This macro is equivalent of calling <a class="el" href="group__odp__scheduler.html#ga94034a7f591f3f549099aebb098f7e05" title="Default scheduling priority level.">odp_schedule_default_prio()</a>. Use direct function call instead. </dd></dl>

</div>
</div>
<a id="ga2ba135fc660e1c050aa25ec6744ec584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ba135fc660e1c050aa25ec6744ec584">&#9670;&nbsp;</a></span>ODP_SCHED_SYNC_PARALLEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_SYNC_PARALLEL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel scheduled queues</p>
<p>The scheduler performs priority scheduling, load balancing, prefetching, etc functions but does not provide additional event synchronization or ordering. It's free to schedule events from single parallel queue to multiple threads for concurrent processing. Application is responsible for queue context synchronization and event ordering (SW synchronization). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_classifier_8c-example.html#a60">odp_classifier.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a116">odp_l2fwd.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a95">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga4b7efc5cfc27ef416312f5adb8bdc392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b7efc5cfc27ef416312f5adb8bdc392">&#9670;&nbsp;</a></span>ODP_SCHED_SYNC_ATOMIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_SYNC_ATOMIC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic queue synchronization</p>
<p>Events from an atomic queue can be scheduled only to a single thread at a time. The thread is guaranteed to have exclusive (atomic) access to the associated queue context, which enables the user to avoid SW synchronization. Atomic queue also helps to maintain event ordering since only one thread at a time is able to process events from a queue.</p>
<p>The atomic queue synchronization context is dedicated to the thread until it requests another event from the scheduler, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by calling <a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4" title="Release the current atomic context.">odp_schedule_release_atomic()</a>. However, this call is just a hint to the implementation and the context may be held until the next schedule call.</p>
<p>When scheduler is enabled as flow-aware, the event flow id value affects scheduling of the event and synchronization is maintained per flow within each queue. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ipsec_api_2odp_ipsec_8c-example.html#a36">ipsec_api/odp_ipsec.c</a>, <a class="el" href="ipsec_crypto_2odp_ipsec_8c-example.html#a39">ipsec_crypto/odp_ipsec.c</a>, <a class="el" href="odp_classifier_8c-example.html#a23">odp_classifier.c</a>, <a class="el" href="odp_debug_8c-example.html#a46">odp_debug.c</a>, <a class="el" href="odp_generator_8c-example.html#a68">odp_generator.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a114">odp_l2fwd.c</a>, <a class="el" href="odp_ping_8c-example.html#a44">odp_ping.c</a>, and <a class="el" href="odp_pktio_8c-example.html#a18">odp_pktio.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga4df3696ebf4528ecc6e69ae3fff040fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df3696ebf4528ecc6e69ae3fff040fd">&#9670;&nbsp;</a></span>ODP_SCHED_SYNC_ORDERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_SYNC_ORDERED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordered queue synchronization</p>
<p>Events from an ordered queue can be scheduled to multiple threads for concurrent processing but still maintain the original event order. This enables the user to achieve high single flow throughput by avoiding SW synchronization for ordering between threads.</p>
<p>The source queue (dequeue) ordering is maintained when events are enqueued to their destination queue(s) within the same ordered queue synchronization context. A thread holds the context until it requests another event from the scheduler, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by calling <a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065" title="Release the current ordered context.">odp_schedule_release_ordered()</a>. However, this call is just a hint to the implementation and the context may be held until the next schedule call.</p>
<p>Events from the same (source) queue appear in their original order when dequeued from a destination queue. The destination queue can have any queue type and synchronization method. Event ordering is based on the received event(s), but also other (newly allocated or stored) events are ordered when enqueued within the same ordered context. Events not enqueued (e.g. freed or stored) within the context are considered missing from reordering and are skipped at this time (but can be ordered again within another context).</p>
<p>Unnecessary event re-ordering may be avoided for those destination queues that do not need to maintain the original event order by setting 'order' queue parameter to ODP_QUEUE_ORDER_IGNORE.</p>
<p>When scheduler is enabled as flow-aware, the event flow id value affects scheduling of the event and synchronization is maintained per flow within each queue. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a115">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga8a6ab4ff9386d9a4ffcb4b19d516a3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a6ab4ff9386d9a4ffcb4b19d516a3fb">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_INVALID&#160;&#160;&#160;((<a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid scheduler group </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a146">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaf463b15ad978dac0bf77c0110232b504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf463b15ad978dac0bf77c0110232b504">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_ALL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Group of all threads. All active worker and control threads belong to this group. The group is automatically updated when new threads enter or old threads exit ODP. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ipsec_api_2odp_ipsec_8c-example.html#a38">ipsec_api/odp_ipsec.c</a>, <a class="el" href="ipsec_crypto_2odp_ipsec_8c-example.html#a41">ipsec_crypto/odp_ipsec.c</a>, <a class="el" href="odp_classifier_8c-example.html#a62">odp_classifier.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a203">odp_l2fwd.c</a>, <a class="el" href="odp_ping_8c-example.html#a46">odp_ping.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a97">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga72125b596aa5d2e61dd61e177516e24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72125b596aa5d2e61dd61e177516e24e">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_WORKER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_WORKER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Group of all worker threads. All active worker threads belong to this group. The group is automatically updated when new worker threads enter or old threads exit ODP. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a204">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="gae8d0a3ad4e57fabf61aa84b59e688a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d0a3ad4e57fabf61aa84b59e688a13">&#9670;&nbsp;</a></span>ODP_SCHED_GROUP_CONTROL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ODP_SCHED_GROUP_CONTROL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predefined scheduler group of all control threads </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga05c15f8076326b98fe2fc534dcc6b319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c15f8076326b98fe2fc534dcc6b319">&#9670;&nbsp;</a></span>odp_schedule_sync_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga05c15f8076326b98fe2fc534dcc6b319">odp_schedule_sync_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scheduler synchronization method </p>

<p class="definition">Definition at line <a class="el" href="api_2abi-default_2schedule__types_8h_source.html#l00046">46</a> of file <a class="el" href="api_2abi-default_2schedule__types_8h_source.html">api/abi-default/schedule_types.h</a>.</p>

</div>
</div>
<a id="ga3cd27b316530d297eab83d851bf2deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd27b316530d297eab83d851bf2deb8">&#9670;&nbsp;</a></span>odp_schedule_group_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scheduler thread group </p>

<p class="definition">Definition at line <a class="el" href="api_2abi-default_2schedule__types_8h_source.html#l00052">52</a> of file <a class="el" href="api_2abi-default_2schedule__types_8h_source.html">api/abi-default/schedule_types.h</a>.</p>

</div>
</div>
<a id="ga33e9d26217f2f689b2611298dec5daf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33e9d26217f2f689b2611298dec5daf7">&#9670;&nbsp;</a></span>odp_schedule_prio_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__odp__scheduler.html#ga33e9d26217f2f689b2611298dec5daf7">odp_schedule_prio_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling priority level. </p>
<p>Priority level is an integer value between <a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5" title="Minimum scheduling priority level.">odp_schedule_min_prio()</a> and <a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf" title="Maximum scheduling priority level.">odp_schedule_max_prio()</a>. Queues with a higher priority value are served with higher priority than queues with a lower priority value. </p>

<p class="definition">Definition at line <a class="el" href="api_2spec_2schedule__types_8h_source.html#l00161">161</a> of file <a class="el" href="api_2spec_2schedule__types_8h_source.html">api/spec/schedule_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab0a0d2673cc7371d5c5d782d13a485b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a0d2673cc7371d5c5d782d13a485b8">&#9670;&nbsp;</a></span>odp_schedule_wait_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t odp_schedule_wait_time </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule wait time. </p>
<p>Converts nanoseconds to wait values for other schedule functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Nanoseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value for the wait parameter in schedule functions </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_classifier_8c-example.html#a35">odp_classifier.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a49">odp_l2fwd.c</a>, <a class="el" href="odp_ping_8c-example.html#a56">odp_ping.c</a>, <a class="el" href="odp_pktio_8c-example.html#a26">odp_pktio.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a28">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="gae4ca1012ebb16ff8b9752b958dc45ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ca1012ebb16ff8b9752b958dc45ce6">&#9670;&nbsp;</a></span>odp_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a> odp_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule an event. </p>
<p>Run event scheduler to find the next highest priority event which is available for the calling thread. Only queues that have been created with ODP_QUEUE_TYPE_SCHED type are connected to the scheduler. Optionally, outputs the source queue of the event. If there's no event available, waits for an event according to the wait parameter setting. Returns ODP_EVENT_INVALID if reaches end of the wait period.</p>
<p>When returns an event, the thread holds the queue synchronization context (atomic or ordered) until the next schedule call (e.g. <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> or <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>). The next call implicitly releases the current context and potentially returns with a new context. User can allow early context release (e.g., see <a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4" title="Release the current atomic context.">odp_schedule_release_atomic()</a> and <a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065" title="Release the current ordered context.">odp_schedule_release_ordered()</a>) for performance optimization.</p>
<p>When successful, this function acts as an acquire memory barrier between the sender and the receiver (the calling thread) of the event. The receiver sees correctly the memory stores done by the sender before it enqueued the event.</p>
<p>When the event was scheduled from an atomic queue, this function acts as an acquire memory barrier between the previous holder of the same atomic synchronization context and the calling thread. When the context is released, a release memory barrier is performed towards the next holder of the context. This ensures that memory stores done when holding an atomic context are correctly visible to other threads that will subsequently hold the same atomic context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramname">wait</td><td>Minimum time to wait for an event. Waits indefinitely if set to ODP_SCHED_WAIT. Does not wait if set to ODP_SCHED_NO_WAIT. Use <a class="el" href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8" title="Schedule wait time.">odp_schedule_wait_time()</a> to convert time to other wait values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next highest priority event </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_EVENT_INVALID</td><td>on timeout and no events available</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>, <a class="el" href="group__odp__scheduler.html#ga7bfbbe5a45d721f9af622296fa97b8e4" title="Release the current atomic context.">odp_schedule_release_atomic()</a>, <a class="el" href="group__odp__scheduler.html#gaab9e0e2bfa0f014069ae7b66bdba0065" title="Release the current ordered context.">odp_schedule_release_ordered()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ipsec_api_2odp_ipsec_8c-example.html#a27">ipsec_api/odp_ipsec.c</a>, <a class="el" href="ipsec_crypto_2odp_ipsec_8c-example.html#a29">ipsec_crypto/odp_ipsec.c</a>, <a class="el" href="odp_classifier_8c-example.html#a37">odp_classifier.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a43">odp_l2fwd.c</a>, <a class="el" href="odp_ping_8c-example.html#a58">odp_ping.c</a>, <a class="el" href="odp_pktio_8c-example.html#a34">odp_pktio.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a12">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga34f1bae924466cc2b57563f8fe2dc0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f1bae924466cc2b57563f8fe2dc0d1">&#9670;&nbsp;</a></span>odp_schedule_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_multi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule multiple events. </p>
<p>Like <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a>, but returns multiple events from a queue. The caller specifies the maximum number of events it is willing to accept. The scheduler is under no obligation to return more than a single event but will never return more than the number specified by the caller. The return code specifies the number of events returned and all of these events always originate from the same source queue and share the same scheduler synchronization context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramname">wait</td><td>Minimum time to wait for an event. Waits infinitely, if set to ODP_SCHED_WAIT. Does not wait, if set to ODP_SCHED_NO_WAIT. Use <a class="el" href="group__odp__scheduler.html#gab0a0d2673cc7371d5c5d782d13a485b8" title="Schedule wait time.">odp_schedule_wait_time()</a> to convert time to other wait values. </td></tr>
    <tr><td class="paramname">events</td><td>Event array for output </td></tr>
    <tr><td class="paramname">num</td><td>Maximum number of events to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events outputted (0 ... num) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_generator_8c-example.html#a91">odp_generator.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaa388723ac8b02b37675476fabd8fb014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa388723ac8b02b37675476fabd8fb014">&#9670;&nbsp;</a></span>odp_schedule_multi_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_multi_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule, wait for events. </p>
<p>Like <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>, but waits infinitely for events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Event array for output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Maximum number of events to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events outputted (1 ... num) </dd></dl>

</div>
</div>
<a id="ga17ae1ac2ac704684d0a7087a311c73f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ae1ac2ac704684d0a7087a311c73f4">&#9670;&nbsp;</a></span>odp_schedule_multi_no_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_multi_no_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__queue.html#ga378c44e791a84a1160f870e3d995db96">odp_queue_t</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__odp__event.html#ga51942509e0d072db63a565cbc1e7204d">odp_event_t</a>&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule, do not wait for events. </p>
<p>Like <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a>, but does not wait for events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td>Output parameter for the source queue (where the event was dequeued from). Ignored if NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Event array for output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Maximum number of events to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events outputted (0 ... num) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a33">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga9868ccb25b6631ef29cc921ee2e522b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9868ccb25b6631ef29cc921ee2e522b0">&#9670;&nbsp;</a></span>odp_schedule_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_pause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause scheduling. </p>
<p>Pause global scheduling for this thread. After this call, only ODP_SCHED_NO_WAIT schedule calls are allowed and these calls will return only locally pre-scheduled events (if any). User can exit the schedule loop only after the schedule function indicates that there's no more (pre-scheduled) events.</p>
<p>Example call pattern:</p>
<p>while (!stop) { odp_event_t ev = odp_schedule(NULL, ODP_SCHED_WAIT); // Process event }</p>
<p><a class="el" href="group__odp__scheduler.html#ga9868ccb25b6631ef29cc921ee2e522b0" title="Pause scheduling.">odp_schedule_pause()</a>;</p>
<p>while (1) { odp_event_t ev = odp_schedule(NULL, ODP_SCHED_NO_WAIT); if (ev == ODP_EVENT_INVALID) break; odp_event_free(ev); } </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a42">odp_l2fwd.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a11">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaf16f217bd1654f854a720130dbd01a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf16f217bd1654f854a720130dbd01a49">&#9670;&nbsp;</a></span>odp_schedule_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume scheduling. </p>
<p>Resume global scheduling for this thread. After this call, all schedule calls will schedule normally (perform global scheduling). </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a48">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga7bfbbe5a45d721f9af622296fa97b8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bfbbe5a45d721f9af622296fa97b8e4">&#9670;&nbsp;</a></span>odp_schedule_release_atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_release_atomic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the current atomic context. </p>
<p>This call is valid only for source queues with atomic synchronization. It hints the scheduler that the user has completed critical section processing in the current atomic context. The scheduler is now allowed to schedule events from the same queue to another thread. However, the context may be still held until the next <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> or <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a> call - this call allows but does not force the scheduler to release the context early.</p>
<p>Early atomic context release may increase parallelism and thus system performance, but user needs to design carefully the split into critical vs. non-critical sections. </p>

</div>
</div>
<a id="gaab9e0e2bfa0f014069ae7b66bdba0065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9e0e2bfa0f014069ae7b66bdba0065">&#9670;&nbsp;</a></span>odp_schedule_release_ordered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_release_ordered </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the current ordered context. </p>
<p>This call is valid only for source queues with ordered synchronization. It hints the scheduler that the user has done all enqueues that need to maintain event order in the current ordered context. The scheduler is allowed to release the ordered context of this thread and avoid reordering any following enqueues. However, the context may be still held until the next <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a> or <a class="el" href="group__odp__scheduler.html#ga34f1bae924466cc2b57563f8fe2dc0d1" title="Schedule multiple events.">odp_schedule_multi()</a> call - this call allows but does not force the scheduler to release the context early.</p>
<p>Early ordered context release may increase parallelism and thus system performance, since scheduler may start reordering events sooner than the next schedule call. </p>

</div>
</div>
<a id="gaa17b9ca6d2b8bd76e31023779455474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17b9ca6d2b8bd76e31023779455474c">&#9670;&nbsp;</a></span>odp_schedule_prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_prefetch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefetch events for next schedule call. </p>
<p>Hint the scheduler that application is about to finish processing the current event(s) and will soon request more events. The scheduling context status is not affect. The call does not guarantee that the next schedule call will return any number of events. It may improve system performance, since the scheduler may prefetch the next (batch of) event(s) in parallel to application processing the current event(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Number of events to prefetch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d91b9144cf2ccdcb112b7376a38aeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d91b9144cf2ccdcb112b7376a38aeaf">&#9670;&nbsp;</a></span>odp_schedule_max_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_max_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum scheduling priority level. </p>
<p>This is the maximum value that can be set to 'prio' field in <a class="el" href="structodp__schedule__param__t.html" title="Scheduler parameters.">odp_schedule_param_t</a> (e.g. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__queue.html#gab985be8c3947fef3da257e16948bf0f0" title="Queue create.">odp_queue_create()</a>). Queues with a higher priority value are served with higher priority than queues with a lower priority value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum scheduling priority level </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ipsec_api_2odp_ipsec_8c-example.html#a34">ipsec_api/odp_ipsec.c</a>, <a class="el" href="ipsec_crypto_2odp_ipsec_8c-example.html#a37">ipsec_crypto/odp_ipsec.c</a>, and <a class="el" href="odp_debug_8c-example.html#a48">odp_debug.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga53b421f0656421e67cc7fd841e5576b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b421f0656421e67cc7fd841e5576b5">&#9670;&nbsp;</a></span>odp_schedule_min_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_min_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum scheduling priority level. </p>
<p>This is the minimum value that can be set to 'prio' field in <a class="el" href="structodp__schedule__param__t.html" title="Scheduler parameters.">odp_schedule_param_t</a> (e.g. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__queue.html#gab985be8c3947fef3da257e16948bf0f0" title="Queue create.">odp_queue_create()</a>). Queues with a higher priority value are served with higher priority than queues with a lower priority value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum scheduling priority level </dd></dl>

</div>
</div>
<a id="ga94034a7f591f3f549099aebb098f7e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94034a7f591f3f549099aebb098f7e05">&#9670;&nbsp;</a></span>odp_schedule_default_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_default_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default scheduling priority level. </p>
<p>This is the default value of 'prio' field in <a class="el" href="structodp__schedule__param__t.html" title="Scheduler parameters.">odp_schedule_param_t</a> (e.g. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__queue.html#ga6fc2ea5eb86152210342f7377d1468e4" title="Initialize queue params.">odp_queue_param_init()</a>). The default value should be suitable for an application that uses single priority level for all its queues (uses scheduler only for load balancing and synchronization). Typically, the default value is between minimum and maximum values, but with a few priority levels it may be close or equal to those.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Default scheduling priority level </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_classifier_8c-example.html#a59">odp_classifier.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a120">odp_l2fwd.c</a>, <a class="el" href="odp_ping_8c-example.html#a42">odp_ping.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a93">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="gae380898e8c1cac6a96cd539a7603a31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae380898e8c1cac6a96cd539a7603a31d">&#9670;&nbsp;</a></span>odp_schedule_num_prio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_num_prio </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of scheduling priorities. </p>
<p>The number of priority levels support by the scheduler. It equals to <a class="el" href="group__odp__scheduler.html#ga9d91b9144cf2ccdcb112b7376a38aeaf" title="Maximum scheduling priority level.">odp_schedule_max_prio()</a> - <a class="el" href="group__odp__scheduler.html#ga53b421f0656421e67cc7fd841e5576b5" title="Minimum scheduling priority level.">odp_schedule_min_prio()</a> + 1.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of scheduling priorities </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_classifier_8c-example.html#a84">odp_classifier.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga3f3af33a2a42b3a9d6e5e3f74bfcb03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d">&#9670;&nbsp;</a></span>odp_schedule_config_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_config_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize schedule configuration options. </p>
<p>Initialize an <a class="el" href="structodp__schedule__config__t.html" title="Schedule configuration.">odp_schedule_config_t</a> to its default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">config</td><td>Pointer to schedule configuration structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a198">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="gaa1b51ebd46adeb6aa7805fccb00144df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b51ebd46adeb6aa7805fccb00144df">&#9670;&nbsp;</a></span>odp_schedule_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structodp__schedule__config__t.html">odp_schedule_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global schedule configuration. </p>
<p>Initialize and configure scheduler with global configuration options to schedule events across different scheduled queues. This function must be called only once and before scheduler is used (any other scheduler function is called except <a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a> and <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a>) or any queues are created (by application itself or by other ODP modules). An application can pass NULL value to use default configuration. It will have the same result as filling the structure with <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a> and then passing it to <a class="el" href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df" title="Global schedule configuration.">odp_schedule_config()</a>.</p>
<p>The initialization sequeunce should be, <a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a> <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a> <a class="el" href="group__odp__scheduler.html#gaa1b51ebd46adeb6aa7805fccb00144df" title="Global schedule configuration.">odp_schedule_config()</a> <a class="el" href="group__odp__scheduler.html#gae4ca1012ebb16ff8b9752b958dc45ce6" title="Schedule an event.">odp_schedule()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to scheduler configuration structure or NULL for the default configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gabde3ebecd35c0442a2e2a20144af0d80" title="Query scheduler capabilities.">odp_schedule_capability()</a>, <a class="el" href="group__odp__scheduler.html#ga3f3af33a2a42b3a9d6e5e3f74bfcb03d" title="Initialize schedule configuration options.">odp_schedule_config_init()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ipsec_api_2odp_ipsec_8c-example.html#a145">ipsec_api/odp_ipsec.c</a>, <a class="el" href="ipsec_crypto_2odp_ipsec_8c-example.html#a122">ipsec_crypto/odp_ipsec.c</a>, <a class="el" href="odp_classifier_8c-example.html#a108">odp_classifier.c</a>, <a class="el" href="odp_debug_8c-example.html#a101">odp_debug.c</a>, <a class="el" href="odp_generator_8c-example.html#a124">odp_generator.c</a>, <a class="el" href="odp_l2fwd_8c-example.html#a202">odp_l2fwd.c</a>, <a class="el" href="odp_ping_8c-example.html#a106">odp_ping.c</a>, <a class="el" href="odp_pktio_8c-example.html#a72">odp_pktio.c</a>, and <a class="el" href="odp_timer_test_8c-example.html#a68">odp_timer_test.c</a>.</dd>
</dl>

</div>
</div>
<a id="gabde3ebecd35c0442a2e2a20144af0d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabde3ebecd35c0442a2e2a20144af0d80">&#9670;&nbsp;</a></span>odp_schedule_capability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_capability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structodp__schedule__capability__t.html">odp_schedule_capability_t</a> *&#160;</td>
          <td class="paramname"><em>capa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query scheduler capabilities. </p>
<p>Outputs schedule capabilities on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">capa</td><td>Pointer to capability structure for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a199">odp_l2fwd.c</a>, and <a class="el" href="odp_sysinfo_8c-example.html#a108">odp_sysinfo.c</a>.</dd>
</dl>

</div>
</div>
<a id="gade17d812771d4e386aac0810b05fa0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade17d812771d4e386aac0810b05fa0e5">&#9670;&nbsp;</a></span>odp_schedule_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> odp_schedule_group_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule group create. </p>
<p>Creates a schedule group with the thread mask. Only threads in the mask will receive events from a queue that belongs to the schedule group. Thread masks of various schedule groups may overlap. There are predefined groups, such as ODP_SCHED_GROUP_ALL and ODP_SCHED_GROUP_WORKER, which are present by default and are automatically updated. The use of group name is optional. Unique names are not required. However, <a class="el" href="group__odp__scheduler.html#ga5021b647374ccf445765138c520aea2c" title="Look up a schedule group by name.">odp_schedule_group_lookup()</a> returns only a single matching group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the schedule group or NULL. Maximum string length is ODP_SCHED_GROUP_NAME_LEN. </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Schedule group handle </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_SCHED_GROUP_INVALID</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gaf463b15ad978dac0bf77c0110232b504">ODP_SCHED_GROUP_ALL</a>, <a class="el" href="group__odp__scheduler.html#ga72125b596aa5d2e61dd61e177516e24e">ODP_SCHED_GROUP_WORKER</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a145">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga789089301ab1da404d927deace0c2492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga789089301ab1da404d927deace0c2492">&#9670;&nbsp;</a></span>odp_schedule_group_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule group destroy. </p>
<p>Destroys a schedule group. All queues belonging to the schedule group must be destroyed before destroying the group. Other operations on this group must not be invoked in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Schedule group handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5021b647374ccf445765138c520aea2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5021b647374ccf445765138c520aea2c">&#9670;&nbsp;</a></span>odp_schedule_group_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a> odp_schedule_group_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a schedule group by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of schedule group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of the first matching schedule group </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ODP_SCHEDULE_GROUP_INVALID</td><td>No matching schedule group found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f7a7ab39ee69f8538edd9dd506127b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7a7ab39ee69f8538edd9dd506127b6">&#9670;&nbsp;</a></span>odp_schedule_group_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a schedule group. </p>
<p>Join a threadmask to an existing schedule group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_l2fwd_8c-example.html#a31">odp_l2fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ga7f8b1785115b6d2be6aae0f5614dc604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8b1785115b6d2be6aae0f5614dc604">&#9670;&nbsp;</a></span>odp_schedule_group_leave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_leave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a schedule group. </p>
<p>Remove a threadmask from an existing schedule group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramname">mask</td><td>Thread mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on failure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Leaving a schedule group means threads in the specified mask will no longer receive events from queues belonging to the specified schedule group. This effect is not instantaneous, however, and events that have been prestaged may still be presented to the masked threads. </dd></dl>

</div>
</div>
<a id="ga0f82ee3eb52b2a0af6c1629334942b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f82ee3eb52b2a0af6c1629334942b5c">&#9670;&nbsp;</a></span>odp_schedule_group_thrmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_thrmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structodp__thrmask__t.html">odp_thrmask_t</a> *&#160;</td>
          <td class="paramname"><em>thrmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a schedule group's thrmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thrmask</td><td>The current thrmask used for this schedule group</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Invalid group specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad76f3ebf512c382a95cb64ac2b843c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76f3ebf512c382a95cb64ac2b843c7f">&#9670;&nbsp;</a></span>odp_schedule_group_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int odp_schedule_group_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__odp__scheduler.html#ga3cd27b316530d297eab83d851bf2deb8">odp_schedule_group_t</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structodp__schedule__group__info__t.html">odp_schedule_group_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve information about a schedule group. </p>
<p>Fills in schedule group information structure with current values. The call is not synchronized with calls modifying the schedule group. So, the application should ensure that it does not simultaneously modify and retrieve information about the same group with this call. The call is not intended for fast path use. The info structure is written only on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">group</td><td>Schedule group handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Pointer to schedule group info struct for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>On success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>On failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb827ae9d816cc6e3bade16f2e4ce00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb827ae9d816cc6e3bade16f2e4ce00d">&#9670;&nbsp;</a></span>odp_schedule_order_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_lock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire ordered context lock. </p>
<p>This call is valid only when holding an ordered synchronization context. Ordered locks are used to protect critical sections that are executed within an ordered context. Threads enter the critical section in the order determined by the context (source queue). Lock ordering is automatically skipped for threads that release the context instead of using the lock.</p>
<p>The number of ordered locks available is set by the lock_count parameter of the schedule parameters passed to <a class="el" href="group__odp__queue.html#gab985be8c3947fef3da257e16948bf0f0" title="Queue create.">odp_queue_create()</a>, which must be less than or equal to queue capability 'max_ordered_locks'. If this routine is called outside of an ordered context or with a lock_index that exceeds the number of available ordered locks in this context results are undefined. The number of ordered locks associated with a given ordered queue may be queried by the <a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> API.</p>
<p>Each ordered lock may be used only once per ordered context. If events are to be processed with multiple ordered critical sections, each should be protected by its own ordered lock. This promotes maximum parallelism by allowing order to maintained on a more granular basis. If an ordered lock is used multiple times in the same ordered context results are undefined. Only one ordered lock can be active in an ordered context at any given time. Results are undefined when multiple ordered locks are acquired in nested fashion within the same ordered context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to be acquired. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a><ul>
<li>1 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f07fe4b73a14a6ef06414a2c10ddc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f07fe4b73a14a6ef06414a2c10ddc2a">&#9670;&nbsp;</a></span>odp_schedule_order_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_unlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ordered context lock. </p>
<p>This call is valid only when holding an ordered synchronization context. Release a previously locked ordered context lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to be released. Results are undefined if the caller does not hold this lock. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4a9ff2ad12781e8ee8cfd722ec7cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a9ff2ad12781e8ee8cfd722ec7cd5c">&#9670;&nbsp;</a></span>odp_schedule_order_unlock_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_unlock_lock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unlock_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release existing ordered context lock and acquire a new lock. </p>
<p>This call is valid only when holding an ordered synchronization context. Release a previously locked ordered context lock and acquire a new ordered context lock. The operation is equivalent to application calling first odp_schedule_order_unlock(unlock_index) and then odp_schedule_order_lock(lock_index). The same constraints apply with this call as with those two.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unlock_index</td><td>Index of the acquired ordered lock in the current context to be released. </td></tr>
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to be acquired. Must be in the range 0...<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d" title="Acquire ordered context lock.">odp_schedule_order_lock()</a>, <a class="el" href="group__odp__scheduler.html#ga8f07fe4b73a14a6ef06414a2c10ddc2a" title="Release ordered context lock.">odp_schedule_order_unlock()</a> </dd></dl>

</div>
</div>
<a id="ga4a2c49c450d10a8d1493f49bb8bda497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a2c49c450d10a8d1493f49bb8bda497">&#9670;&nbsp;</a></span>odp_schedule_order_lock_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_lock_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous ordered context lock Request an ordered context lock to be acquired. </p>
<p>Starts an ordered context lock acquire operation, but does not wait until the lock has been acquired. Application can use this call to potentially interleave some processing within waiting for this lock. Each start lock call must be paired with a wait call that blocks until the lock has been acquired. Locks cannot be acquired in nested fashion i.e each start call must follow a paring wait and unlock calls, before using another lock. The same constraints apply as with <a class="el" href="group__odp__scheduler.html#gafb827ae9d816cc6e3bade16f2e4ce00d" title="Acquire ordered context lock.">odp_schedule_order_lock()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to start acquire operation. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39473bcdcdf480a827cbbf6249aee394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39473bcdcdf480a827cbbf6249aee394">&#9670;&nbsp;</a></span>odp_schedule_order_lock_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_order_lock_wait </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous ordered context lock wait Wait for a previously started lock acquire operation to finish. </p>
<p>Lock index must match with the previous start call. Ordered lock acquisition will be completed during this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_index</td><td>Index of the ordered lock in the current context to complete acquire operation. Must be in the range 0..<a class="el" href="group__odp__queue.html#ga420874d79ccbc465c8b6be4127bfe824" title="Queue lock count.">odp_queue_lock_count()</a> - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae92168433885df11eed3d22040b68e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92168433885df11eed3d22040b68e38">&#9670;&nbsp;</a></span>odp_schedule_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void odp_schedule_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug info about scheduler. </p>
<p>Print implementation defined information about scheduler to the ODP log. The information is intended to be used for debugging. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="odp_debug_8c-example.html#a50">odp_debug.c</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
